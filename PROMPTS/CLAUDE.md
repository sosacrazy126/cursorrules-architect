# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

Context Engineering is a comprehensive framework for moving beyond simple prompt engineering to sophisticated context design, orchestration, and optimization. The repository implements a biological metaphor progression from atoms to neural fields, demonstrating how to build increasingly sophisticated AI systems through context engineering principles.

## Architecture

The codebase follows a progressive complexity model based on biological metaphors:

```
atoms → molecules → cells → organs → neural systems → neural fields → unified theory
  │        │         │        │            │               │            │
single   few-shot   memory   multi-     cognitive       context     meta-recursive
prompts  examples   + state  agent      tools +         fields +    frameworks +
                             systems    reasoning       persistence self-evolution
```

### Key Components

1. **Foundations** (`00_foundations/`): Core theory and principles
2. **Guides** (`10_guides_zero_to_hero/`): Practical Python implementations
3. **Templates** (`20_templates/`): Reusable components and patterns
4. **Examples** (`30_examples/`): Progressive complexity demonstrations
5. **Reference** (`40_reference/`): Deep documentation and evaluation
6. **Protocols** (`60_protocols/`): Protocol shells and schema definitions
7. **Cognitive Tools** (`cognitive-tools/`): Advanced reasoning frameworks
8. **Context Schemas** (`context-schemas/`): Structured context definitions

## Development Commands

This repository is primarily educational and research-focused. Most files are markdown documentation or Python demonstration scripts.

### Running Python Examples

```bash
# Navigate to guides directory
cd 10_guides_zero_to_hero/

# Run minimal prompt experiments
python 01_min_prompt.py

# Run context expansion tutorials
python 02_expand_context.py

# Run control loop demonstrations
python 03_control_loops.py

# Run RAG recipe examples
python 04_rag_recipes.py

# Run prompt programming examples
python 05_prompt_programs.py

# Run schema design examples
python 06_schema_design.py

# Run recursive pattern examples
python 07_recursive_patterns.py
```

### Running Cognitive Tools

```bash
# Navigate to cognitive tools directory
cd cognitive-tools/cognitive-programs/

# Run program library demonstrations
python program-library.py

# Run architecture examples
cd ../cognitive-architectures/
python architecture-examples.py
```

## Core Concepts

### Progressive Complexity Levels

The framework operates on six complexity levels:

1. **Atoms**: Single instructions, basic prompts
2. **Molecules**: Few-shot examples, context pairs
3. **Cells**: Memory and state management
4. **Organs**: Multi-agent coordination
5. **Neural Systems**: Cognitive tools and reasoning frameworks
6. **Neural Fields**: Continuous context fields with persistence

### Protocol Shells

The repository includes reusable protocol shells for:
- Attractor co-emergence
- Recursive emergence
- Memory persistence
- Field resonance
- Self-repair mechanisms

### Cognitive Tools Architecture

Based on IBM Zurich research, the framework includes:
- Understanding operations
- Reasoning operations
- Verification operations
- Composition operations
- Emergent reasoning patterns

## Key Files to Understand

### Entry Points
- `README.md`: Project overview and research context
- `00_foundations/01_atoms_prompting.md`: Start here for theory
- `10_guides_zero_to_hero/01_min_prompt.py`: Start here for practice

### Architecture Documentation
- `STRUCTURE_v3.md`: Detailed structural mapping
- `context-schemas/context_v6.0.json`: Latest context schema
- `cognitive-tools/README.md`: Cognitive tools overview

### Templates and Patterns
- `20_templates/minimal_context.yaml`: Basic context template
- `20_templates/neural_field_context.yaml`: Advanced field context
- `60_protocols/shells/`: Protocol shell definitions

### Research Integration
- `CITATIONS_v3.md`: Research references and connections
- `40_reference/cognitive_patterns.md`: Pattern catalog
- `cognitive-tools/cognitive-schemas/`: Knowledge representations

## Working with This Repository

### Understanding the Theory
1. Start with `00_foundations/` in numerical order
2. Each foundation builds on previous concepts
3. Focus on the biological metaphor progression

### Practical Implementation
1. Work through `10_guides_zero_to_hero/` sequentially
2. Each guide includes runnable Python code
3. Experiment with the provided examples

### Using Templates
1. Copy templates from `20_templates/`
2. Customize for your specific use case
3. Follow the YAML structure for context assembly

### Advanced Features
1. Explore `cognitive-tools/` for reasoning frameworks
2. Study `60_protocols/` for protocol shells
3. Examine `context-schemas/` for structured contexts

## Code Style and Conventions

### Python Code
- Uses type hints and dataclasses
- Follows PEP 8 naming conventions
- Includes comprehensive docstrings
- Implements abstract base classes for extensibility

### YAML/JSON Schemas
- Uses semantic versioning for schemas
- Includes metadata and documentation
- Follows consistent naming patterns
- Supports progressive complexity levels

### Documentation
- Uses progressive disclosure principles
- Includes visual ASCII diagrams
- Provides both theory and practice
- Links to research papers and sources

## Integration Patterns

### With LLM APIs
- Templates include token budget management
- Supports various LLM providers
- Includes evaluation metrics
- Provides fallback strategies

### With Context Systems
- Modular component design
- Supports memory persistence
- Enables recursive context updates
- Includes field dynamics

### With Research Frameworks
- Implements latest research findings
- Provides citation tracking
- Supports experimental validation
- Enables collaborative evolution

## Testing and Validation

### Evaluation Frameworks
- Quality metrics in `40_reference/eval_checklist.md`
- Cognitive pattern validation
- Token budget optimization
- Performance benchmarking

### Experimental Design
- Progressive complexity testing
- Ablation studies support
- Comparative evaluation
- Field dynamics measurement

## Advanced Usage

### Meta-Recursive Frameworks
- Self-reflective context systems
- Interpretable evolution tracking
- Collaborative co-emergence
- Cross-modal integration

### Field Theory Applications
- Continuous context fields
- Attractor dynamics
- Symbolic residue tracking
- Persistence mechanisms

### Protocol Orchestration
- Multi-protocol coordination
- Dynamic field assembly
- Emergent behavior detection
- System-level optimization

## Contributing

When contributing to this repository:

1. **Follow the biological metaphor**: Ensure contributions fit within the atoms → fields progression
2. **Include both theory and practice**: Provide markdown documentation and Python implementations
3. **Maintain research connections**: Link to relevant research papers and citations
4. **Test across complexity levels**: Verify functionality at different scales
5. **Document context engineering principles**: Explain how contributions advance the field

## Support and Learning Resources

- **NotebookLM Integration**: Chat with the repository using the provided NotebookLM link
- **Research Papers**: See `CITATIONS_v3.md` for comprehensive research connections
- **Community**: Contribute to `50_contrib/` for collaborative development
- **Examples**: Progressive complexity demonstrations in `30_examples/`

This repository represents a comprehensive framework for context engineering that bridges theoretical research with practical implementation, enabling the development of sophisticated AI systems through principled context design.